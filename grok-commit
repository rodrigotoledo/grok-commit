#!/usr/bin/env ruby

require 'open3'    # For running Git commands
require 'net/http' # For HTTP requests
require 'json'     # For JSON parsing
require 'optparse' # For command-line argument parsing

# Parse command-line options
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: grok-commit [--set-language=<lang>]\nAvailable languages: en, pt-BR"

  opts.on("--set-language=LANG", "Set the language for commit messages (e.g., en, pt-BR)") do |lang|
    options[:set_language] = lang
  end
end.parse!

# Handle language setting
if options[:set_language]
  valid_languages = ['en', 'pt-BR']
  unless valid_languages.include?(options[:set_language])
    puts "Error: Invalid language '#{options[:set_language]}'. Use 'en' or 'pt-BR'."
    exit 1
  end

  # Determine shell config file (prefer ~/.zshrc if Zsh, else ~/.bashrc)
  shell_config = File.exist?(File.expand_path('~/.zshrc')) ? '~/.zshrc' : '~/.bashrc'

  # Update or append GROK_COMMIT_LANGUAGE to shell config
  config_path = File.expand_path(shell_config)
  config_content = File.exist?(config_path) ? File.read(config_path) : ''
  language_line = "export GROK_COMMIT_LANGUAGE=\"#{options[:set_language]}\""

  if config_content.match?(/^export GROK_COMMIT_LANGUAGE=/)
    # Replace existing language setting
    new_content = config_content.gsub(/^export GROK_COMMIT_LANGUAGE=.*/, language_line)
    File.write(config_path, new_content)
  else
    # Append new language setting with a newline before
    File.open(config_path, 'a') { |f| f.puts("\n#{language_line}") }
  end

  puts "Language set to '#{options[:set_language]}' in #{shell_config}. Reload your shell with 'source #{shell_config}'."
  exit 0
end

# Retrieve the API key from environment
api_key = ENV['GROK_API_KEY']
if api_key.nil? || api_key.empty?
  puts "Error: Please set the GROK_API_KEY environment variable with your xAI API key."
  puts "For API details, visit https://x.ai/api."
  exit 1
end

# Get language from environment (default to English)
language = ENV['GROK_COMMIT_LANGUAGE'] || 'en'
unless ['en', 'pt-BR'].include?(language)
  puts "Error: Invalid GROK_COMMIT_LANGUAGE '#{language}'. Use 'en' or 'pt-BR'."
  exit 1
end

# Capture the diff of staged changes (limit to 5,000 characters)
diff_output, diff_status = Open3.capture2('git diff --cached')
diff_output = diff_output[0..5_000] # Limit to reduce tokens
if diff_output.empty?
  puts "No staged changes found. Please run 'git add' first."
  exit 1
end
unless diff_status.success?
  puts "Error running git diff: #{diff_status}"
  exit 1
end

# Optimized prompt for Grok based on language
prompt = <<~PROMPT
  Generate a concise Git commit message in #{language} (e.g., "feat: adds new functionality").
  Base it on these changes:

  #{diff_output}
PROMPT

# API call configuration
api_endpoint = 'https://api.x.ai/v1/chat/completions'
model = 'grok-3'  # More stable and cost-effective

# Prepare the request body
request_body = {
  model: model,
  messages: [
    { role: 'system', content: 'You are an assistant that generates clear and professional Git commit messages.' },
    { role: 'user', content: prompt }
  ],
  max_tokens: 200,  # Increased to avoid "length" cutoff
  temperature: 0.7
}.to_json

# Make the HTTP request
uri = URI(api_endpoint)
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_PEER

request = Net::HTTP::Post.new(uri.path)
request['Authorization'] = "Bearer #{api_key}"
request['Content-Type'] = 'application/json'
request.body = request_body

begin
  response = http.request(request)
  response_code = response.code.to_i
  if response_code == 500
    puts "Error 500: Internal server issue at xAI. Try again later or check https://status.x.ai/."
    puts "Response body: #{response.body}"
    exit 1
  end
  unless response_code == 200
    puts "API Error: Code #{response_code} - #{response.body}"
    exit 1
  end
rescue => e
  puts "Request error: #{e.message}. Check the API key with 'echo $GROK_API_KEY'."
  exit 1
end

# Extract the generated message
response_data = JSON.parse(response.body)
generated_message = response_data['choices']&.first&.dig('message', 'content')&.strip
if generated_message.nil? || generated_message.empty?
  puts "No commit message generated. API response: #{response_data.inspect}"
  exit 1
end

# Perform the commit automatically
commit_command = "git commit -m '#{generated_message.gsub("'", "\\'")}'"
puts "Running: #{commit_command}"
success = system(commit_command)
unless success
  puts "Error executing commit. Check Git status with 'git status'."
  exit 1
end